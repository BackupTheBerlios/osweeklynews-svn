<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd" [
<!ENTITY % myentities SYSTEM "entities.ent">
%myentities;
]>
<!--
  
  This work is licensed under the
  Creative Commons Attribution-ShareAlike 3.0 Unported License
  by Sascha Manns. To view a copy of this license, visit
  http://creativecommons.org/licenses/by-sa/3.0/ or send a letter to
  Creative Commons
  171 Second Street
  Suite 300
  San Francisco California 94105
  USA.
  
-->
<sect1 role="tipsandtricks">
  <title>Tips and Tricks</title>
  <sect2>
    <title>For Desktop Users</title>
    <blockquote>
      <title>
        <ulink url="http://www.makeuseof.com/tag/give-computer-voice-espeak-windows-linux/">MakeUseOf/Justin Pot: Give Your Computer A Voice With eSpeak [Windows &amp; Linux]</ulink>
      </title>
      <para>Let your computer do the talking. Install eSpeak and you can make your computer say anything, in a wide variety of languages.</para>
      <para>Looking for a lightweight <ulink url="http://www.makeuseof.com/dir/tag/text-to-speech/">text to speech</ulink> program? Whether you want to listen to your favorite blog while doing the dishes, or just make your computer say naughty words to your friends so you can giggle like schoolchildren, <ulink url="http://espeak.sourceforge.net/">eSpeak</ulink> is a great tool for the job. It’s “a compact open source software speech synthesizer for English and other languages” according to its website. You can use official versions of eSpeak on <ulink url="apt:espeak-gui">Linux</ulink> (Editors Note: the link is just for Debian/Ubuntu users) and <ulink url="http://espeak.sourceforge.net/download.html">Windows</ulink>. (...)</para>
      <para>Editors Note: eSpeak packages for openSUSE are <ulink url="http://software.opensuse.org/search?p=1&amp;baseproject=ALL&amp;q=espeak">available via OBS</ulink>.</para>
<!-- ($ Id: 11.11.11 sat $)-->    </blockquote>
    <blockquote>
      <title>
        <ulink url="http://linuxaria.com/article/gedit-an-easy-to-use-text-editor-with-many-advanced-features?lang=en">Linuxaria/Frank Harris-Smith: gEdit, an easy to use text editor with many advanced features</ulink>
      </title>
      <para><ulink url="http://www.gnome.org/projects/gedit/">gEdit</ulink> is a serious text editor in the tradition of many editors that the programmer or code jockey will appreciate – syntax highlighting in many source codes, script formats, markup formats, and even some Scientific formats.</para>
      <para>I write a lot of HTML code and I find the multiple undo/redo, find, search &amp; replace, and the built-in code-aware spelling checker essential on a daily basis.</para>
      <para>But that’s me. I’m writing about what I use on a daily basis and gEdit is always open on my PC of the moment. I do HTML coding for my personal website, keep lists of “To-Do” items, use it as a scratch pad to paste whatever nuggets of wisdom I find on the Internet and generally use it for quickly jotting down whatever I need to note. (...)</para>
<!-- ($ Id: 11.11.11 sat $)-->    </blockquote>
  </sect2>
  <sect2>
    <title>For Commandline/Script Newbies</title>
    <blockquote>
      <title>
        <ulink url="http://technonstop.com/fun-with-unix-linux-find-command">TechNonStop/Abdullah Chougle: Fun with the Unix/Linux find command!</ulink>
      </title>
      <para>This article lists some of the more useful ways of utilizing the find command.</para>
      <para>These commands will work on most Linux distributions, and have been tested on recent versions of Ubuntu and SUSE. (...)</para>
<!-- ($ Id: 11.11.11 sat $)-->    </blockquote>
  </sect2>
  <sect2>
    <title>For Developers and Programmers</title>
    <blockquote>
      <title>
        <ulink url="http://www.linuxjournal.com/content/man-make-primer-make-utility">Linux Journal/Adrian Hannah: man make: a Primer on the Make Utility</ulink>
      </title>
      <para>In a compiled language, the makefile is arguably the most important part of any programming project. To compile your project, you first have to compile each source file into an object file, which in turn needs to be linked with system libraries into the final executable file. Each command can have a considerable number of arguments added in. That&apos;s a lot of typing and a lot of potential for mistakes. The more source files you have, the more complex the compilation process becomes, unless you use makefiles. Most Linux users have at least a cursory knowledge of make and makefiles (because that&apos;s how we build software packages for our systems), but not much more than that. Most developers probably don&apos;t have too much in-depth experience with makefiles, because most Integrated Development Environments (IDEs) have the capability of managing makefiles for them. Although this is convenient most of the time, knowing more about how make works and what goes into makefiles can help you troubleshoot compilation errors down the road. (...)</para>
<!-- ($ Id: 11.11.11 sat $)-->    </blockquote>
  </sect2>
  <sect2>
    <title>For System Administrators</title>
    <blockquote>
      <title>
        <ulink url="http://sellingfreesoftwareforaliving.blogspot.com/2011/11/install-and-configure-tftp-server-for.html">Han Wen Kam: Install and configure TFTP server for PXE boot environment</ulink>
      </title>
      <para>This blog entry describes how you would install and configure the TFTP (Trivial File
        Transfer Protocol) server for the purpose of building a PXE boot environment. The tftp
        server would transfer the syslinux binaries to boot up your physical machine. It will also
        present a text-based menu for the user to select what operating system to install.
        (...)</para>
<!-- ($ Id: 10.11.11 sm $)-->    </blockquote>
    <!--
    <blockquote>
      <title>
        <ulink url="http://stick.gk2.sk/blog/2011/11/getting-ssh-fingerprints-for-machines-in-your-network/">Pavol Rusnak: Getting SSH fingerprints for machines in your network</ulink>
      </title>
      <para>Some time ago we were trying to get SSH fingerprints for all machines in our local
        network. Solution is not that straightforward, but it’s not a rocket science either:
        <programlisting>
#!/bin/bash
tmpfile=$(mktemp)
for i in $(seq 2 254); do
    ssh-keyscan -t rsa,dsa,ecdsa 192.168.1.$i &gt; &gt; $tmpfile
    done
ssh-keygen -l -f $tmpfile
rm -f $tmpfile
        </programlisting>
      </para>
      <para>First, we retrieve the keys using ssh-keyscan, store them into temporary file and
        compute fingerprints afterwards using ssh-keygen. Or is there a less complex and more
        elegant solution?</para>
      <para>PS: Thanks <ulink url="http://administratosphere.wordpress.com/2011/05/28/getting-and-verifying-ssh-fingerprints/">David</ulink> for kicking in the right direction.</para>
    </blockquote> -->
    <blockquote>
      <title>
        <ulink url="http://olex.openlogic.com/wazi/2011/openssl-expert-tips-and-tricks-test-and-benchmark-servers/">Wazi/Carla Schroder: OpenSSL Expert Tips and Tricks: Test and Benchmark Servers</ulink>
      </title>
      <para><ulink url="http://olex.openlogic.com/packages/openssl">OpenSSL</ulink>, the open source toolkit for implementing the Secure Sockets Layer (SSL) and Transport Layer Security (TLS) protocols, is an everyday essential for most Linux admins responsible for secure networking. But OpenSSL includes a wealth of features that even grizzled veterans may not be familiar with. You can use OpenSSL to test POP and IMAP servers, and test server connection speeds, among other interesting tricks. (...)</para>
<!-- ($ Id: 11.11.11 sat $)-->    </blockquote>
    <blockquote>
      <title>
        <ulink url="http://jeffhoogland.blogspot.com/2011/11/ncdu-answer-to-question.html">Jeff Hoogland: NCDU - The Answer to a Question</ulink>
      </title>
      <para>The question is:</para>
      <para>Where did all my disc space go?</para>
      <para>The answer? An ncurses based application called NCDU. NCDU is a simple, light-weight disc-usage analyzer. I like NCDU because of it&apos;s few dependencies, in fact installing in on my system took less than 1mb worth of additional space. It is fast, because like all good applications it is written entirely in C. (...)</para>
      <para>Editors Note: ncdu packages for openSUSE can be found in <ulink url="http://download.opensuse.org/repositories/utilities/">utilities repo</ulink>.</para>
<!-- ($ Id: 11.11.11 sat $)-->    </blockquote>
  </sect2>
</sect1>
